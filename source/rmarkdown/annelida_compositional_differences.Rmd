---
title: "Annelida: verschillen in taxonomische samenstelling tussen groepen van stalen"
author: "Sam Lambrechts, Io Deflem, Emma Cartuyvels, Hans Van Calster"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
    code_folding: hide
editor_options:
  markdown:
    wrap: sentence
bibliography: references.yaml
---

```{r setup, include=FALSE}
library(knitr)
library(here)
opts_chunk$set(echo = TRUE, out.width = "100%")
opts_knit$set(root.dir = here::here())

if (!"phyloseq" %in% rownames(installed.packages())) {
  remotes::install_github("joey711/phyloseq")
}
library(phyloseq)
library(vegan)
library(ggplot2)
library(dplyr)
library(tidyr)
if (!"tidytacos" %in% rownames(installed.packages())) {
  remotes::install_github("lebeerlab/tidytacos")
}
library(tidytacos)


mbag_folder <- "G:/Gedeelde drives/PRJ_MBAG" # nolint


if (!"GenomeInfoDbData" %in% rownames(installed.packages())) {
install.packages(
  "GenomeInfoDbData",
  repos = "https://bioconductor.org/packages/3.17/data/annotation")
}
if (!"sccomp" %in% rownames(installed.packages())) {
  remotes::install_github("stemangiola/sccomp")
}
library(sccomp)
```

# Inlezen data

```{=html}
<!--
In plaats van een .Rdata object, zouden we hier beter de bronbestanden inlezen met de code die hiervoor nodig.
Met bronbestanden bedoel ik hier gewoon de drie tabelletjes die samen het phyloseq object vormen.
Deze tabelletjes kunnen best gewoon csv bestanden zijn die we inlezen.
-->
```
```{r load-rdata-file}
path_naar_bestand <- file.path(
    mbag_folder,
    "4c_bodembiodiversiteit",
    "data",
    "statistiek",
    "Annelida",
    "phyloseq_Olig01_Annelida",
    "physeq_Olig01_Annelida_species.Rdata"
  )

load(path_naar_bestand)
```

Het bestand dat wordt ingelezen is `r basename(path_naar_bestand)`.

```{r}
tidy_physeq <- tidytacos::from_phyloseq(physeq_Olig01_Annelida_species) %>%
  tidytacos::remove_empty_samples()
```

# Analyse van verschillen in samenstelling

## Ordinaties

-   We verwijderen taxa die minder dan `frequency_threshold` voorkomen in de stalen
-   We transformeren met de robuuste "centered-log-ratio" transformatie omdat we werken met compositionele data waar enkel relatieve verschillen in abundantie betekenisvol zijn
-   Eerst voeren we een principale componenten analyse uit op deze data
-   Daarna behouden we de eerste `n` principale componenten die samen 90% van de totale variatie verklaren. Deze stap zal helpen om ruis uit de dataset te verwijderen.
-   Tot slot voeren we een *t*-SNE analyse uit met als input de getrimde PCA oplossing en visualiseren we de resultaten

```{r function-ordinations}
calc_ordinations <- function(
    tacos_data,
    frequency_threshold,
    use_rank = NULL
) {

  data <- tacos_data %>%
    {
      if (!is.null(use_rank)) {
        tidytacos::aggregate_taxa(., rank = use_rank) # nolint
      } else {
        . # nolint
      }
    } %>%
    tidytacos::filter_counts(
      .by = "taxon_id", n() > frequency_threshold)

  print(tidytacos::tacosum(data))

  counts <- data$counts %>%
    pivot_wider(
      id_cols = "sample_id",
      names_from = "taxon_id",
      values_from = "count",
      values_fill = 0)

  pca1 <- prcomp(
    vegan::decostand(
      counts %>% select(-.data$sample_id),
      method = "rclr"))
  d <- pca1$sdev^2
  truncate_axis <- sum(cumsum(d) / sum(d) < 0.9)
  message(sprintf(
    "Calculating tsne based on first %s axes from PCA solution",
    truncate_axis))
  tsne1 <- tsne::tsne(pca1$x[, 1:truncate_axis])

  plotdata <-
    bind_cols(
      as_tibble(vegan::scores(pca1, display = "sites", choices = 1:2)),
      as_tibble(tsne1),
      counts %>%
        dplyr::select(.data$sample_id)) %>%
    left_join(data$samples, by = "sample_id")

  return(list(pca = pca1, tsne = tsne1, plotdata = plotdata))
}

plot_pca <- function(plotdata, colour = NULL) {
  ggpca <- plotdata %>%
    ggplot() +
    geom_point(
      aes(x = .data$PC1, y = .data$PC2, colour = {{colour}})
    ) +
    geom_vline(xintercept = 0, alpha = 0.3) +
    geom_hline(yintercept = 0, alpha = 0.3) +
    stat_ellipse(aes(
      x = .data$PC1, y = .data$PC2, colour = {{colour}}),
      level = 0.95) +
    labs(x = "Eerste principale component",
         y = "Tweede principale component")
    return(ggpca)
}

plot_tsne <- function(plotdata, colour = NULL) {
  ggtsne <- plotdata %>%
    ggplot() +
    geom_point(
      aes(x = .data$V1, y = .data$V2, colour = {{colour}})) +
    geom_vline(xintercept = 0, alpha = 0.3) +
    geom_hline(yintercept = 0, alpha = 0.3) +
    stat_ellipse(aes(
      x = .data$V1, y = .data$V2, colour = {{colour}}), level = 0.95) +
    labs(x = "Eerste t-SNE as",
         y = "Tweede t-SNE as")
    return(ggtsne)
}
```

### Zonder aggregatie van taxa:

```{r}
ordination <- calc_ordinations(
  tacos_data = tidy_physeq,
  frequency_threshold = 10)
```

```{r}
plot_pca(ordination$plotdata, colour = Landgebruik_MBAG)
```

```{r}
plot_pca(ordination$plotdata, colour = Diepte)
```

```{r}
plot_tsne(ordination$plotdata, colour = Landgebruik_MBAG)
```

```{r}
plot_tsne(ordination$plotdata, colour = Diepte)
```

### Aggregatie op genus niveau

```{r calc-ordinations}
ordination <- calc_ordinations(
  tacos_data = tidy_physeq,
  use_rank = "genus",
  frequency_threshold = 10)
```

```{r}
plot_pca(ordination$plotdata, colour = Landgebruik_MBAG)
```

```{r}
plot_pca(ordination$plotdata, colour = Diepte)
```

```{r}
plot_tsne(ordination$plotdata, colour = Landgebruik_MBAG)
```

```{r}
plot_tsne(ordination$plotdata, colour = Diepte)
```

## `sccomp`: differentiÃ«le samenstelling en variabiliteitsanalyse

We fitten een multivariaat beta-binomiaal regressiemodel met diepte en landgebruik als factoren en proefvlak als random intercept [@mangiola2023].

```{r sccomp-inputs}
max_taxa <- 10
used_rank <- "genus"
sccomp_data_annelida <- tidy_physeq %>%
  aggregate_taxa(rank = used_rank) %>%
  tidytacos::add_prevalence() %>%
  tidytacos::mutate_taxa(
    keep = min_rank(desc(occurrence)) < max_taxa
  ) %>%
  filter_taxa(
    keep,
    !is.na(genus)
  ) %>%
  tidytacos::everything() %>%
  mutate(count = as.integer(count)) %>%
  select(taxon_id, sample_id, count, sample, Cmon_PlotID, Diepte,
         Landgebruik_MBAG, genus, occurrence) %>%
  filter(
    complete.cases(.)
  )
```

Voor deze analyse, aggregeren we de taxa tot `r used_rank` niveau en beperken we de analyse tot de `r max_taxa` taxa met hoogste prevalentie.
Dit is goed voor `r round(sum(sccomp_data_annelida$count) / sum(tidy_physeq$counts$count) * 100)` % van alle reads.

```{r sccomp-annelida}
fs::dir_create(here("source", "brms_models"))
if (!file.exists(here("source", "brms_models", "s_annelida.rds"))) {
  s_annelida <- sccomp_estimate(
    .data = sccomp_data_annelida,
    formula_composition = ~
      Landgebruik_MBAG
    + Diepte
    + Landgebruik_MBAG:Diepte
    + (1 | Cmon_PlotID),
    .sample = sample_id,
    .cell_group = taxon_id,
    .count = count,
    verbose = TRUE,
    max_sampling_iterations = 2000,
    bimodal_mean_variability_association = FALSE
  )
  saveRDS(s_annelida,
          here("source", "brms_models", "s_annelida.rds"))
}

s_annelida <- readRDS(here("source", "brms_models", "s_annelida.rds"))
```

```{r sccomp-test}
sctest <- sccomp::sccomp_test(s_annelida)
plots <- plot(sctest)
```

```{r sccomp-taxon-info}
sccomp_data_annelida %>%
  group_by(taxon_id, genus, occurrence) %>%
  summarise(sum_reads = sum(count)) %>%
  kable()
```

```{r sccomp-boxplot-landgebruik}
plots$boxplot[[1]]
```

```{r sccomp-boxplot-diepte}
plots$boxplot[[2]]
```

```{r sccomp-ci1d, fig.height = 200/25.4}
plots$credible_intervals_1D
```

# Referenties
