---
title: "Modelling presence-absence compositional differences"
author: "Hans Van Calster"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
    code_folding: hide
editor_options:
  markdown:
    wrap: sentence
  chunk_output_type: console
---


```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(echo = TRUE)
library(here)
opts_chunk$set(echo = TRUE, error = TRUE, out.width = "100%")
opts_knit$set(root.dir = here::here())
library(ggplot2)
library(dplyr)
library(tidyr)
library(purrr)
mbag_bodem_folder <- "G:/Gedeelde drives/PRJ_MBAG/4c_bodembiodiversiteit" # nolint
library(gllvm)
library(phyloseq)
library(tidytacos)
library(corrplot)
library(sccomp)
```


```{r emmeans-stuff}
# cf https://github.com/JenniNiku/gllvm/discussions/159
library(emmeans)
recover_data.gllvm <- function(object, component = c("main", "LV"), ...){
 component <- match.arg(component)
  if(component == "main"){
    fcall <- getCall(object)
    X = object$X
    if(is.null(fcall$formula)){
      stop("Model without formula not yet implemented. Please refit your model using the formula argument.")
      # fcall$formula = as.formula(object$formula)
    }
  }else{
    fcall <- getCall(object)
    X = object$lv.X
    object$X <- X
    if(is.null(fcall$lv.formula)){
      stop("Model without lv.formula not yet implemented. Please refit your model using the formula argument.")
    }
    fcall$formula <- fcall$lv.formula
  }
  
 fcall$formula <- as.formula(paste0("~0+species+",paste0("species:", labels(terms(as.formula(fcall$formula))), collapse = "+")))
 X = cbind(do.call("rbind",replicate(ncol(object$y),data.frame(X,check.rows = FALSE),simplify=FALSE)),species = as.factor(rep(colnames(object$y),each=nrow(object$X))))
 frm = model.frame(fcall$formula, X)
 
  emmeans:::recover_data.call(getCall(object), trms = terms(fcall$formula), na.action = NULL, data = X, params = "pi", frame = frm, pwts = NULL, addl.vars = NULL)
}


emm_basis.gllvm = function(object, trms, xlev, grid, component = c("main", "LV"), ...){
  # if(is.null(object$call$formula)){
  #   fcall <- getCall(object)
  #   fcall$formula = as.formula(object$formula)
  #   fcall$formula <- as.formula(paste0("~0+",paste0(labels(terms(as.formula(fcall$formula))),":species",collapse = "+")))
  #   trms = terms(as.formula(object$formula))
  #   }
  component = match.arg(component)
   xlev$species = colnames(object$y) # make sure species ordering is correctly retained

  if(component == "main"){
    m = model.frame(trms, grid, na.action = na.pass, xlev = xlev)
    X = model.matrix(trms, m)
    
    bhat = cbind(object$param$beta0,object$params$Xcoef)
    V = vcov(object) # per species organized
    V <- V[row.names(V)=="b", colnames(V)=="b"]
    #reorder V to per covariate
    V <- V[order(rep(1:ncol(bhat),times=ncol(object$y))),order(rep(1:ncol(bhat),times=ncol(object$y)))]
  }else if((object$num.lv.c+object$num.RR)>0 && component == "LV"){
    m = model.frame(trms, grid, na.action = na.pass, xlev = xlev)
    X = model.matrix(trms, m)
    
    bhat = cbind(object$params$beta0, object$params$theta[,1:(object$num.lv.c+object$num.RR),drop=FALSE]%*%t(object$params$LvXcoef))
    V = gllvm:::RRse(object, return.covb = TRUE) # per covariate organised
    covMat <- object$Hess$cov.mat.mod
    colnames(covMat) <- row.names(covMat) <- names(object$TMBfn$par[object$Hess$incl])
    Sb <- covMat[colnames(covMat)=="b",colnames(covMat)=="b"]
    if(!object$beta0com){
      bidx <- rep(c(TRUE,rep(FALSE,ncol(Sb)/ncol(object$y)-1)), ncol(object$y))
    }else{
      bidx <- c(TRUE,rep(FALSE, ncol(Sb)-1))
    }
    Sb <- Sb[bidx,bidx]
    
    # Add covariances for intercept.
    K = ncol(object$lv.X.design)
    d = object$num.lv.c+object$num.RR
    p = ncol(object$y)

    covMat <- covMat[colnames(covMat)%in%c("b","b_lv","lambda"),colnames(covMat)%in%c("b","b_lv","lambda")]
    covMat <- covMat[c(bidx,rep(TRUE,sum(colnames(covMat)%in%c("b_lv","lambda")))),c(bidx,rep(TRUE,sum(colnames(covMat)%in%c("b_lv","lambda"))))]
    #add first row and column of zeros before b_lv, for first species
    covMat <- rbind(covMat[1:(p+d*K),, drop=FALSE],0,covMat[-c(1:(p+d*K)),, drop=FALSE])
    covMat <- cbind(covMat[,1:(p+d*K), drop=FALSE],0,covMat[,-c(1:(p+d*K)), drop=FALSE])
    
    if(d>1){
      idx<-which(c(upper.tri(object$params$theta[,1:d],diag=T)))[-1]
      
      #add zeros where necessary
      for(q in 1:length(idx)){
        covMat <- rbind(covMat[1:(p+d*K+idx[q]-1),],0,covMat[(p+d*K+idx[q]):ncol(covMat),])
        covMat <- cbind(covMat[,1:(p+d*K+idx[q]-1)],0,covMat[,(p+d*K+idx[q]):ncol(covMat)])
      }
    }
    row.names(covMat)[row.names(covMat)==""]<-colnames(covMat)[colnames(covMat)==""]<-"lambda"
    
    covLb <- covMat[colnames(covMat) =="lambda",colnames(covMat)=="b",drop=FALSE]
    if(object$beta0com){
      covLb <- do.call(cbind,replicate(ncol(object$y),covLB, simplify=FALSE))
    }
    covLB <- covMat[colnames(covMat)=="lambda",colnames(covMat)=="b_lv", drop=FALSE]
    covb_lvb <- covMat[colnames(covMat) =="b_lv",colnames(covMat)=="b",drop=FALSE]
    if(object$beta0com){
      covb_lvb <- do.call(cbind,replicate(ncol(object$y),covb_lvb, simplify=FALSE))
    }
    covBb <- matrix(0,  K*p,ncol(object$y))

    for(k in 1:K){
        for(j in 1:p){
          for(j2 in 1:p){
            for(q in 1:d){
              covBb[j+p*(k-1),j2] <- covBb[j+p*(k-1),j2]+object$params$LvXcoef[k,d]*covLb[j+p*(q-1),j2]+object$params$theta[j,q]*covb_lvb[(q-1)*K+k,j2]
            }
        }
        }
    }
  V = rbind(cbind(Sb,t(covBb)),cbind(covBb,V))
  }else{
    stop("Invalid model.")
  }

  nbasis=matrix(NA)
  dfargs = list(df = Inf)
  dffun <- function(k, dfargs)Inf
  
  list(X=X, bhat=c(bhat), nbasis = nbasis, V=V,dffun = dffun, dfargs = dfargs)
}

emmeans::.emm_register("gllvm","gllvm")
```


```{r input-parameters}
threshold_present <- 1
min_prevalence <- 30
```


# Read data


The following files are used as input for the analyses:

-   "MBAG_stratfile_v2_cleaned_17.csv"
-   "physeq_Olig01_Annelida_species.Rdata"

```{r inlezen}
metadata <- readr::read_csv(
  file.path(
    mbag_bodem_folder,
    "data",
    "Stratificatie_MBAG_plots",
    "MBAG_stratfile_v2_cleaned_17.csv"
  )
) %>%
  janitor::clean_names() %>%
  rename(
    ph_kcl = p_h_k_cl,
    swc_grav = sw_cgrav,
    swc_vol = sw_cvol,
    cn_stockbased = c_n_stockbased,
    c_density = cdensity,
    n_density = ndensity
  ) %>%
  mutate(
    landgebruik = factor(
      landgebruik_mbag,
      levels = c(
        "Akker", "Tijdelijk grasland", "Blijvend grasland",
        "Residentieel grasland", "Natuurgrasland", "Heide", "Moeras"
      )
    ),
    diepte = gsub("_|/", "-", diepte) |> factor()
  )
load(
  file.path(
    mbag_bodem_folder,
    "data", "statistiek", "Annelida", "phyloseq",
    "physeq_Olig01_Annelida_species.Rdata"
  )
)
physeq_olig01_annelida_species <- physeq_Olig01_Annelida_species |> # nolint
  phyloseq::subset_samples(
    !Landgebruik_MBAG %in% c("Moeras", "Heide")
  )
```

Land use types `Moeras` and `Heide` are removed from the dataset.

```{r}
sample_data(physeq_olig01_annelida_species)$Landgebruik_MBAG <- factor(
  sample_data(physeq_olig01_annelida_species)$Landgebruik_MBAG,
  levels = c(
    "Akker", "Tijdelijk grasland", "Blijvend grasland",
    "Residentieel grasland", "Natuurgrasland"
  )
)
```

We aggregate the taxonomic resolution to the genus level.

```{r}
# aggregating to genus
physeq_olig01_annelida_genus <- physeq_olig01_annelida_species |>
  phyloseq::tax_glom(taxrank = "genus")
```

We use a threshold for read counts equal to `r threshold_present` to consider a taxon as present.
Thus, taxa with fewer than `r threshold_present` read counts are coded as absent from a sample.

```{r}
tt_ann <- from_phyloseq(physeq_olig01_annelida_genus)


design <- metadata %>%
  filter(!landgebruik %in% c("Moeras", "Heide")) %>%
  distinct(sample, diepte, landgebruik) %>%
  droplevels()

ann <- everything(tt_ann) %>%
  janitor::clean_names() %>%
  dplyr::select(count, sample, cmon_plot_id, genus) %>%
  mutate(pa = ifelse(count >= threshold_present, 1, 0)) %>%
  inner_join(design, by = join_by(sample)) %>%
  complete(
    nesting(sample, cmon_plot_id, diepte, landgebruik),
    genus,
    fill = list(pa = 0, count = 0)
  ) %>%
  rename(id = sample)

```

We further restrict the data by including only taxa which have a prevalence equal or higher than `r min_prevalence`.

```{r}
ann <- ann %>%
  filter(
    sum(pa) >= min_prevalence,
    .by = c(genus)
  )
```


# GLLVM

GLLVM = Generalized linear latent variable models.

> The latent variables $u_i$ can be thought of as unmeasured environmental variables, or as ordination scores, capturing the main axes of covariation of abundance (after controlling for observed predictors $x_i$). We assume that these latent variables are independent across sites and standard normally distributed. 

>  $\alpha_i$ are optional site effects which can be chosen as either fixed or random effects ($\alpha_i \approx \mathcal{N}(\mu,\,\sigma^{2})$). The row effects $\alpha_i$ can be included for site total abundance standardization, that is, all other terms in the model can then be subsequently interpreted as modelling relative abundance or compositional effects

TO DO: include random effect for plot location. How??

For this model, we transformed the count data to presence absence data.
The reason why we do this, is that we are currently unsure how the count data from eDNA surveys should be handled (but see next section about `sccomp` and the comparison).

GLLVM deals with correlation between taxa by inclusion of latent variables.
Latent variables are similar in spirit to classical ordination axes (such as principal components in a PCA).
It is therefore also called a model-based ordination approach.

GLLVM requires you to specify the number of latent variables and we fix this in this exercise to two latent variables.

In a first attempt, and to get familiar with GLLVM, we will fit a model with two latent variables but no covariates.
This can be considered an "unconstrained" ordination.

As GLLVM is just an extension of GLM (generalized linear models), we also need to tell the model which distribution for the response variables should be used.
In our case, we choose a binomial distribution with a probit link.
The probit link is different from the normally chosen logit link for binomial models and this has to do with the fitting algorithm (default method uses a variational approximation method) which cannot deal with logit link.


```{r}
ann_wide <- ann %>%
  select(-count) %>%
  pivot_wider(names_from = genus, values_from = pa)

y <- ann_wide %>%
  dplyr::select(where(is.numeric)) %>%
  as.matrix()

x_env <- ann_wide %>%
  dplyr::select(where(\(x) is.factor(x) | is.character(x)))
design <- x_env %>%
  dplyr::select(id, cmon_plot_id)

```

```{r}
# unconstrained ordination without row effect
unc_ord <- gllvm(
  y = y,
  family = binomial(link = "probit"),
  num.lv = 2,
  sd.errors = TRUE)
```

The taxon correlations can be visualised using a classical biplot or more directly using a correlation matrix plot.
The sort order of taxa in the correlation plot is determined by a hierarchical clustering of the taxa.

```{r}
covars <- c("landgebruik", "diepte")
plotlis <- vector("list", length(covars))
.pardefault <- par()
par(mfrow = c(1,2), mar=c(4,4,2,2))
for (i in seq_along(covars)) {
  ordiplot(
    unc_ord, symbols = TRUE,
    s.colors = ann_wide[[covars[i]]],
    ind.spp = NULL,
    biplot = TRUE,
    main = covars[i]
  )
}

```


```{r}
par(.pardefault)
cormat_unc_ord <- getResidualCor(unc_ord)
corrplot(
  cormat_unc_ord,
  diag = FALSE,
  type = "lower", method = "square", tl.srt = 25, order = "hclust")
```

Next, we add covariates `landgebruik`, `diepte` and their interaction to the model and again show the resulting biplot and correlation plot.

```{r}
# constrained ordination without row effect
constr_ord <- gllvm(
  y = y,
  X = x_env,
  formula = ~ landgebruik + diepte + landgebruik:diepte,
  family = binomial(link = "probit"),
  num.lv = 2,
  sd.errors = TRUE)

```

```{r}
plotlis <- vector("list", length(covars))
par(mfrow = c(1,2), mar=c(4,4,2,2))
for (i in seq_along(covars)) {
  ordiplot(
    constr_ord,
    symbols = TRUE,
    s.colors = ann_wide[[covars[i]]],
    ind.spp = NULL,
    biplot = TRUE,
    main = covars[i]
  )
}
par(.pardefault)
```


```{r}
cormat_constr_ord <- getResidualCor(constr_ord)
corrplot(
  cormat_constr_ord,
  diag = FALSE,
  type = "lower", method = "square", tl.srt = 25, order = "hclust")
```


Finally, we can calculate difference contrast for land use types where we choose `Akker` as the reference level against which is compared.

```{r gllvm-contrasts}
constr_ord_emm <- emmeans(
  constr_ord, ~ landgebruik,
  by = c("species", "diepte"))

head(constr_ord_emm)
# contrasts in link = probit scale
constr_ord_contrasts <-
  contrast(
    constr_ord_emm, method = "trt.vs.ctrl",
    type = "response") |>
  confint()

# probit differences backtransform to percentage point changes
ppc <- function(d, r) pnorm(d + r) - pnorm(r)

reference_akker <- constr_ord_emm %>%
  as_tibble() %>%
  filter(landgebruik == "Akker") %>%
  select(-landgebruik) %>%
  rename_with(.cols = where(is.double), \(x) paste0("akker_", x))

plots <- constr_ord_contrasts %>%
  as_tibble() %>%
  inner_join(reference_akker) %>%
  group_by(contrast) |>
  filter(SE < 5) %>%
  filter(sign(asymp.LCL) == sign(asymp.UCL)) %>%
  mutate(
    estimate = ppc(estimate, akker_emmean),
    asymp.LCL = ppc(asymp.LCL, akker_asymp.LCL),
    asymp.UCL = ppc(asymp.UCL, akker_asymp.UCL)
  ) %>%
  nest() |>
  mutate(
    plot = purrr::map2(
      data, contrast,
      function(x, y) {
        x$species <- reorder(x$species, x$estimate)
        ggplot(x) +
          geom_pointrange(
            aes(
              x = species,
              y = estimate,
              ymin = asymp.LCL,
              ymax = asymp.UCL,
              colour  = diepte),
            position = position_dodge(width = 0.5)
          ) +
          geom_hline(yintercept = 0) +
          scale_y_continuous(labels = scales::percent) +
          labs(y = "Verschil in kans op voorkomen",
               title = y) +
          coord_flip()
        }
    )
  )

patchwork::wrap_plots(
  plots$plot,
  guides = "collect",
  axis_titles = "collect"
  ) &
  patchwork::plot_annotation(title = "Verschillen met akkers")
```




# SCCOMP


```{r sccomp-model}
sccomp_dir <- here::here(
    "data", "compositional_analysis", "sccomp_draws_files"
  )
fs::dir_create(sccomp_dir)
gi_file <- file.path(sccomp_dir, ".gitignore")
fs::file_create(
  gi_file
)
writeLines(
  text = c("*", "!.gitignore"),
  con = gi_file
)

# filter same taxa as used for gllvm
ann_sccomp <- ann %>%
  filter(genus %in% colnames(y)) %>%
  mutate(count = as.integer(count))

m1 <- sccomp_estimate(
  .data = ann_sccomp,
  formula_composition =
    ~ landgebruik + diepte + landgebruik:diepte + (1 | cmon_plot_id),
  formula_variability = ~ 1,
  .sample = id,
  .cell_group = genus,
  .abundance = count,
  cores = 4,
  output_directory = sccomp_dir, # might want to change this
  bimodal_mean_variability_association = FALSE,
  percent_false_positive = 5,
  inference_method = "pathfinder", # 'hmc'
  # ... passed to cmdstanr method $sampling (igv hmc)
  verbose = FALSE
)
```


Check Rhat!

- Rhat < 1.01 is OK
- Rhat between 1.01 and 1.1 is worrying
- Rhat > 1.1 bad


```{r}
hist(m1$c_rhat)
```

Check ESS (effective sample size)!

- ESS > 100 is OK
- ESS between 20 and 100 might be enough
- ESS < 20 problematic

```{r}
hist(m1$c_ess_bulk)
hist(m1$c_ess_tail)
```

If problems:

- try `hmc` algorithm
- increase number of iterations

Calculate `FDR`:

E.g. which taxa differ significantly from `akker` can be calculated with contrasts:

```{r}
threshold <- 0.1
m1_contrast <- sccomp_test(
  m1,
  contrasts = c(
    a_ng_010 = "landgebruikNatuurgrasland",
    a_ng_1030 = "-`diepte10-30` + landgebruikNatuurgrasland + `landgebruikNatuurgrasland:diepte10-30`", # nolint
    a_tg_010 = "`landgebruikTijdelijk grasland`",
    a_tg_1030 = "-`diepte10-30` + `landgebruikTijdelijk grasland` + `landgebruikTijdelijk grasland:diepte10-30`", # nolint
    a_bg_010 = "`landgebruikBlijvend grasland`",
    a_bg_1030 = "-`diepte10-30` + `landgebruikBlijvend grasland` + `landgebruikBlijvend grasland:diepte10-30`", # nolint
    a_rg_010 = "`landgebruikResidentieel grasland`",
    a_rg_1030 = "-`diepte10-30` + `landgebruikResidentieel grasland` + `landgebruikResidentieel grasland:diepte10-30`" # nolint
    ),
  test_composition_above_logit_fold_change = threshold
)

```

These contrasts are in logit (=log-odds) scale and represent log-odds ratios:

$$
\begin{align*}
\log\left(\frac{P_{R_{0-10}}}{1-P_{R_{0-10}}}\right) = \text{log-odds } R_{0-10}
\tag*{Intercept parameter: Akker (R for reference) and 0-10 cm}\\

\text{log odds } T_{0-10} - \text{log odds } R_{0-10} & =
\log\left(\frac{\text{odds } T_{0-10}}{\text{odds } R_{0-10}}\right)
\tag*{Land-use T parameter = difference contrast}
\end{align*}
$$

We can transform the difference contrasts from the log-odds differences to odds-ratios for visualisation and easier interpretation.

A value of 2 means that the odds one of the grassland types for the taxon is double the odds in agricultural fields.
Conversely, an odds-ratio equal to 0.5 means that the odds for the taxon is half of the odds in agricultural fields.
Only taxa that are significant after `FDR` correction are shown.



```{r sccomp-contrasts}
m1_plots <- m1_contrast |>
  filter(
    c_FDR <= 0.05
  ) |>
  mutate(
    Diepte = ifelse(grepl("010", parameter), "0-10", "10-30"),
    Landgebruik = gsub("^a_(.*)_\\d+", "\\1", parameter),
    Landgebruik = factor(
      Landgebruik,
      levels = c("tg", "bg", "rg", "ng"),
      labels = c("Tijdelijk grasland", "Blijvend grasland",
                 "Residentieel grasland", "Natuurgrasland")
    )) |>
  group_by(Landgebruik) |>
  nest() |>
  mutate(
    plot = purrr::map2(
      data, Landgebruik,
      function(x, y) {
        x$genus <- reorder(x$genus, x$c_effect)
        ggplot(x) +
          geom_pointrange(
            aes(
              x = genus, y = c_effect, ymin = c_lower, ymax = c_upper,
              colour  = Diepte),
            position = position_dodge(width = 0.5)
          ) +
          geom_hline(yintercept = 0) +
          geom_hline(yintercept = threshold, alpha = 0.2) +
          geom_hline(yintercept = -threshold, alpha = 0.2) +
          scale_y_continuous(
            breaks = log(
              c(1 / 50, 1 / 20, 1 / 10, 1 / 5, 1 / 2, 1, 2, 5, 10, 20, 50)),
            labels = \(x) format(exp(x), drop0trailing = TRUE)
          ) +
          coord_flip() +
          labs(
            title = y, y = "Odds-ratio"
          )
        }
    )
  )

patchwork::wrap_plots(
  m1_plots$plot,
  guides = "collect",
  axis_titles = "collect"
  ) &
  patchwork::plot_annotation(title = "Verschillen met akkers")
```


# Comparison


```{r comp, fig.height = 8}
sccomp_effects <- m1_contrast |>
  filter(
    c_FDR <= 0.05
  ) |>
  mutate(
    diepte = ifelse(grepl("010", parameter), "0-10", "10-30"),
    landgebruik = gsub("^a_(.*)_\\d+", "\\1", parameter),
    landgebruik = factor(
      landgebruik,
      levels = c("tg", "bg", "rg", "ng"),
      labels = c("Tijdelijk grasland", "Blijvend grasland",
                 "Residentieel grasland", "Natuurgrasland")
    ),
    contrast = paste0(landgebruik, " - Akker"),
    effect_sign = sign(c_effect)
    ) %>%
  select(genus, diepte, contrast, effect_sign, effect = c_effect) %>%
  mutate(method = "sccomp")

gllvm_effects <- constr_ord_contrasts %>%
  as_tibble() %>%
  inner_join(reference_akker) %>%
  group_by(contrast) |>
  filter(SE < 5) %>%
  filter(sign(asymp.LCL) == sign(asymp.UCL)) %>%
  mutate(
    effect_sign = sign(estimate)
  ) %>%
  ungroup() %>%
  select(genus = species, diepte, contrast, effect_sign, effect = estimate) %>%
  mutate(method = "gllvm")

combined <- bind_rows(gllvm_effects, sccomp_effects)

combined %>%
  ggplot() +
  geom_point(aes(x = method, y = genus, colour = factor(effect_sign))) +
  facet_grid(contrast ~ diepte, scales = "free_y")
```


```{r comp-not-filtered}
sccomp_effects_not_filtered <- m1_contrast |>
  mutate(
    diepte = ifelse(grepl("010", parameter), "0-10", "10-30"),
    landgebruik = gsub("^a_(.*)_\\d+", "\\1", parameter),
    landgebruik = factor(
      landgebruik,
      levels = c("tg", "bg", "rg", "ng"),
      labels = c("Tijdelijk grasland", "Blijvend grasland",
                 "Residentieel grasland", "Natuurgrasland")
    ),
    contrast = paste0(landgebruik, " - Akker")
    ) %>%
  select(genus, diepte, contrast, effect = c_effect) %>%
  mutate(method = "sccomp")

gllvm_effects_not_filtered <- constr_ord_contrasts %>%
  as_tibble() %>%
  group_by(contrast) |>
  filter(SE < 5) |>
  ungroup() %>%
  select(genus = species, diepte, contrast, effect = estimate) %>%
  mutate(method = "gllvm")

combined_not_filtered <- bind_rows(
  gllvm_effects_not_filtered,
  sccomp_effects_not_filtered
)

combined_not_filtered %>%
  pivot_wider(names_from = method, values_from = effect) %>%
  ggplot(aes(x = gllvm, y = sccomp)) +
  geom_point(aes(colour = contrast, shape = diepte)) +
  geom_smooth(alpha = 0.2) +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 0) +
  labs(title = "Difference contrast estimates (reference = Akker)")
```



