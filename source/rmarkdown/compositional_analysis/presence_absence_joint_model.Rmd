---
title: "Modelling presence-absence compositional differences"
author: "Hans Van Calster"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    toc: true
    toc_float: true
    code_folding: hide
editor_options:
  markdown:
    wrap: sentence
  chunk_output_type: console
---


```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(echo = TRUE)
library(here)
opts_chunk$set(echo = TRUE, error = TRUE, out.width = "100%")
opts_knit$set(root.dir = here::here())
library(ggplot2)
library(dplyr)
library(tidyr)
library(purrr)
mbag_bodem_folder <- "G:/Gedeelde drives/PRJ_MBAG/4c_bodembiodiversiteit" # nolint
library(gllvm)
library(phyloseq)
library(tidytacos)
```


```{r emmeans-stuff}
library(emmeans)
recover_data.gllvm <- function(object, component = c("main", "LV"), ...){
 component <- match.arg(component)
  if(component == "main"){
    fcall <- getCall(object)
    X = object$X
    if(is.null(fcall$formula)){
      stop("Model without formula not yet implemented. Please refit your model using the formula argument.")
      # fcall$formula = as.formula(object$formula)
    }
  }else{
    fcall <- getCall(object)
    X = object$lv.X
    object$X <- X
    if(is.null(fcall$lv.formula)){
      stop("Model without lv.formula not yet implemented. Please refit your model using the formula argument.")
    }
    fcall$formula <- fcall$lv.formula
  }
  
 fcall$formula <- as.formula(paste0("~0+species+",paste0("species:", labels(terms(as.formula(fcall$formula))), collapse = "+")))
 X = cbind(do.call("rbind",replicate(ncol(object$y),data.frame(X,check.rows = FALSE),simplify=FALSE)),species = as.factor(rep(colnames(object$y),each=nrow(object$X))))
 frm = model.frame(fcall$formula, X)
 
  emmeans:::recover_data.call(getCall(object), trms = terms(fcall$formula), na.action = NULL, data = X, params = "pi", frame = frm, pwts = NULL, addl.vars = NULL)
}


emm_basis.gllvm = function(object, trms, xlev, grid, component = c("main", "LV"), ...){
  # if(is.null(object$call$formula)){
  #   fcall <- getCall(object)
  #   fcall$formula = as.formula(object$formula)
  #   fcall$formula <- as.formula(paste0("~0+",paste0(labels(terms(as.formula(fcall$formula))),":species",collapse = "+")))
  #   trms = terms(as.formula(object$formula))
  #   }
  component = match.arg(component)
   xlev$species = colnames(object$y) # make sure species ordering is correctly retained

  if(component == "main"){
    m = model.frame(trms, grid, na.action = na.pass, xlev = xlev)
    X = model.matrix(trms, m)
    
    bhat = cbind(object$param$beta0,object$params$Xcoef)
    V = vcov(object) # per species organized
    V <- V[row.names(V)=="b", colnames(V)=="b"]
    #reorder V to per covariate
    V <- V[order(rep(1:ncol(bhat),times=ncol(object$y))),order(rep(1:ncol(bhat),times=ncol(object$y)))]
  }else if((object$num.lv.c+object$num.RR)>0 && component == "LV"){
    m = model.frame(trms, grid, na.action = na.pass, xlev = xlev)
    X = model.matrix(trms, m)
    
    bhat = cbind(object$params$beta0, object$params$theta[,1:(object$num.lv.c+object$num.RR),drop=FALSE]%*%t(object$params$LvXcoef))
    V = gllvm:::RRse(object, return.covb = TRUE) # per covariate organised
    covMat <- object$Hess$cov.mat.mod
    colnames(covMat) <- row.names(covMat) <- names(object$TMBfn$par[object$Hess$incl])
    Sb <- covMat[colnames(covMat)=="b",colnames(covMat)=="b"]
    if(!object$beta0com){
      bidx <- rep(c(TRUE,rep(FALSE,ncol(Sb)/ncol(object$y)-1)), ncol(object$y))
    }else{
      bidx <- c(TRUE,rep(FALSE, ncol(Sb)-1))
    }
    Sb <- Sb[bidx,bidx]
    
    # Add covariances for intercept.
    K = ncol(object$lv.X.design)
    d = object$num.lv.c+object$num.RR
    p = ncol(object$y)

    covMat <- covMat[colnames(covMat)%in%c("b","b_lv","lambda"),colnames(covMat)%in%c("b","b_lv","lambda")]
    covMat <- covMat[c(bidx,rep(TRUE,sum(colnames(covMat)%in%c("b_lv","lambda")))),c(bidx,rep(TRUE,sum(colnames(covMat)%in%c("b_lv","lambda"))))]
    #add first row and column of zeros before b_lv, for first species
    covMat <- rbind(covMat[1:(p+d*K),, drop=FALSE],0,covMat[-c(1:(p+d*K)),, drop=FALSE])
    covMat <- cbind(covMat[,1:(p+d*K), drop=FALSE],0,covMat[,-c(1:(p+d*K)), drop=FALSE])
    
    if(d>1){
      idx<-which(c(upper.tri(object$params$theta[,1:d],diag=T)))[-1]
      
      #add zeros where necessary
      for(q in 1:length(idx)){
        covMat <- rbind(covMat[1:(p+d*K+idx[q]-1),],0,covMat[(p+d*K+idx[q]):ncol(covMat),])
        covMat <- cbind(covMat[,1:(p+d*K+idx[q]-1)],0,covMat[,(p+d*K+idx[q]):ncol(covMat)])
      }
    }
    row.names(covMat)[row.names(covMat)==""]<-colnames(covMat)[colnames(covMat)==""]<-"lambda"
    
    covLb <- covMat[colnames(covMat) =="lambda",colnames(covMat)=="b",drop=FALSE]
    if(object$beta0com){
      covLb <- do.call(cbind,replicate(ncol(object$y),covLB, simplify=FALSE))
    }
    covLB <- covMat[colnames(covMat)=="lambda",colnames(covMat)=="b_lv", drop=FALSE]
    covb_lvb <- covMat[colnames(covMat) =="b_lv",colnames(covMat)=="b",drop=FALSE]
    if(object$beta0com){
      covb_lvb <- do.call(cbind,replicate(ncol(object$y),covb_lvb, simplify=FALSE))
    }
    covBb <- matrix(0,  K*p,ncol(object$y))

    for(k in 1:K){
        for(j in 1:p){
          for(j2 in 1:p){
            for(q in 1:d){
              covBb[j+p*(k-1),j2] <- covBb[j+p*(k-1),j2]+object$params$LvXcoef[k,d]*covLb[j+p*(q-1),j2]+object$params$theta[j,q]*covb_lvb[(q-1)*K+k,j2]
            }
        }
        }
    }
  V = rbind(cbind(Sb,t(covBb)),cbind(covBb,V))
  }else{
    stop("Invalid model.")
  }

  nbasis=matrix(NA)
  dfargs = list(df = Inf)
  dffun <- function(k, dfargs)Inf
  
  list(X=X, bhat=c(bhat), nbasis = nbasis, V=V,dffun = dffun, dfargs = dfargs)
}

emmeans::.emm_register("gllvm","gllvm")
```


# Read data

```{r inlezen}
metadata <- readr::read_csv(
  file.path(
    mbag_bodem_folder,
    "data",
    "Stratificatie_MBAG_plots",
    "MBAG_stratfile_v2_cleaned_17.csv"
  )
) %>%
  janitor::clean_names() %>%
  rename(
    ph_kcl = p_h_k_cl,
    swc_grav = sw_cgrav,
    swc_vol = sw_cvol,
    cn_stockbased = c_n_stockbased,
    c_density = cdensity,
    n_density = ndensity
  ) %>%
  mutate(
    landgebruik = factor(
      landgebruik_mbag,
      levels = c(
        "Akker", "Tijdelijk grasland", "Blijvend grasland",
        "Residentieel grasland", "Natuurgrasland", "Heide", "Moeras"
      )
    ),
    diepte = gsub("_|/", "-", diepte) |> factor()
  )
load(
  file.path(
    mbag_bodem_folder,
    "data", "statistiek", "Annelida", "phyloseq",
    "physeq_Olig01_Annelida_species.Rdata"
  )
)
physeq_olig01_annelida_species <- physeq_Olig01_Annelida_species |> # nolint
  phyloseq::subset_samples(
    !Landgebruik_MBAG %in% c("Moeras", "Heide")
  )
```



```{r}
sample_data(physeq_olig01_annelida_species)$Landgebruik_MBAG <- factor(
  sample_data(physeq_olig01_annelida_species)$Landgebruik_MBAG,
  levels = c(
    "Akker", "Tijdelijk grasland", "Blijvend grasland",
    "Residentieel grasland", "Natuurgrasland"
  )
)
```

```{r}
# aggregating to genus
physeq_olig01_annelida_genus <- physeq_olig01_annelida_species |>
  phyloseq::tax_glom(taxrank = "genus")
```

```{r}
tt_ann <- from_phyloseq(physeq_olig01_annelida_genus)

threshold_present <- 1

design <- metadata %>%
  filter(!landgebruik %in% c("Moeras", "Heide")) %>%
  distinct(sample, diepte, landgebruik) %>%
  droplevels()

ann <- everything(tt_ann) %>%
  janitor::clean_names() %>%
  dplyr::select(count, sample, cmon_plot_id, genus) %>%
  mutate(pa = ifelse(count >= threshold_present, 1, 0)) %>%
  dplyr::select(-count) %>%
  inner_join(design, by = join_by(sample)) %>%
  complete(
    nesting(sample, cmon_plot_id, diepte, landgebruik),
    genus,
    fill = list(pa = 0)
  ) %>%
  rename(id = sample)

```




TO DO: include random effect for plot location. How??


```{r}
ann_wide <- ann %>%
  pivot_wider(names_from = genus, values_from = pa)

y <- ann_wide %>%
  dplyr::select(where(is.numeric)) %>%
  as.matrix()
# restrict to taxa with prevalence >= prevalence
min_prevalence <- 30
y <- y[,colSums(y) >= min_prevalence]

x_env <- ann_wide %>%
  dplyr::select(where(\(x) is.factor(x) | is.character(x)))
design <- x_env %>%
  dplyr::select(id, cmon_plot_id)

# unconstrained ordination without row effect
unc_ord <- gllvm(
  y = y,
  family = binomial(link = "probit"),
  num.lv = 2,
  sd.errors = TRUE)

.pardefault <- par()
ordiplot(
  unc_ord, symbols = TRUE, s.colors = ann_wide$diepte,
  ind.spp = NULL,
  biplot = TRUE
)

# constrained ordination without row effect
constr_ord <- gllvm(
  y = y,
  X = x_env,
  formula = ~ landgebruik + diepte + landgebruik:diepte,
  family = binomial(link = "probit"),
  num.lv = 2,
  sd.errors = TRUE)

constr_ord_emm <- emmeans(
  constr_ord, ~ landgebruik,
  by = c("species", "diepte"))

constr_ord_contrasts <- contrast(constr_ord_emm, method = "trt.vs.ctrl") |>
  confint()

plots <- constr_ord_contrasts %>%
  as_tibble() %>%
  group_by(contrast) |>
  filter(SE < 5) %>%
  nest() |>
  mutate(
    plot = purrr::map2(
      data, contrast,
      function(x, y) {
        x$species <- reorder(x$species, x$estimate)
        ggplot(x) +
          geom_pointrange(
            aes(
              x = species, y = estimate, ymin = asymp.LCL,
              ymax = asymp.UCL,
              colour  = diepte),
            position = position_dodge(width = 0.5)
          ) +
          geom_hline(yintercept = 0) +
          scale_y_continuous(
            breaks = log(
              c(1 / 50, 1 / 20, 1 / 10, 1 / 5, 1 / 2, 1, 2, 5, 10, 20, 50)),
            labels = \(x) format(exp(x), drop0trailing = TRUE)
          ) +
          coord_flip() +
          labs(
            title = y, y = "Odds-ratio"
          )
        }
    )
  )

patchwork::wrap_plots(
  plots$plot,
  guides = "collect",
  axis_titles = "collect"
  ) &
  patchwork::plot_annotation(title = "Verschillen met akkers")

```

